{"version":3,"file":"/packages/carlodicelico:tokbox.js","sources":["carlodicelico:tokbox/server/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,iC;AACA,0C;;AAEA,qD;AACA,0C;AACA,E;;AAEA,2D;AACA,kB;AACA,0B;AACA,uC;AACA,+D;AACA,kC;AACA,O;AACA,K;;AAEA,mB;AACA,E;;AAEA,sE;AACA,mC;AACA,wD;AACA,E;;AAEA,qE;AACA,kB;AACA,qC;AACA,oE;AACA,yB;AACA,O;AACA,K;;AAEA,iB;AACA,E;;AAEA,2D;AACA,kB;AACA,qC;AACA,0D;AACA,yB;AACA,O;AACA,K;;AAEA,iB;AACA,E;;AAEA,0D;AACA,4C;AACA,E;;AAEA,6B;AACA,4B;AACA,mB;AACA,c;;AAEA,yB;AACA,uB;AACA,gC;AACA,iB;AACA,mB;AACA,yB;AACA,oB;AACA,U;;AAEA,wB;AACA,iC;AACA,uB;AACA,gB;AACA,+B;AACA,0B;AACA,S;AACA,O;AACA,K;AACA,Q;;AAEA,gB;AACA,c;AACA,E;AACA,qB;AACA,uD;AACA,U;AACA,0B;AACA,G;AACA,E","sourcesContent":["OpenTok = Npm.require('opentok');\nvar Future = Npm.require('fibers/future');\n\nOpenTokClient = function OpenTokClient(key, secret) {\n  this._client = new OpenTok(key, secret);\n};\n\nOpenTokClient.prototype.createSession = function(options) {\n  var self = this;\n  options = options || {};\n  var sessionId = sync(function(done) {\n    self._client.createSession(options, function(err, result) {\n      done(err, result.sessionId);\n    });\n  });\n\n  return sessionId;\n};\n\nOpenTokClient.prototype.generateToken = function(sessionId, options) {\n  options = _.clone(options) || {};\n  return this._client.generateToken(sessionId, options);\n};\n\nOpenTokClient.prototype.startArchive = function(sessionId, options) {\n  var self = this;\n  var archive = sync(function(done) {\n    self._client.startArchive(sessionId, options, function(result) {\n      done(null, result);\n    });\n  });\n\n  return archive;\n};\n\nOpenTokClient.prototype.stopArchive = function(sessionId) {\n  var self = this;\n  var archive = sync(function(done) {\n    self._client.stopArchive(sessionId, function(result) {\n      done(null, result);\n    });\n  });\n\n  return archive;\n};\n\nOpenTokClient.prototype.getArchive = function(archiveId) {\n  return this._client.getArchive(archiveId);\n};\n\nfunction sync(asynFunction) {\n  var future = new Future();\n  var sent = false;\n  var payload;\n\n  setTimeout(function() {\n    asynFunction(done);\n    function done(err, result) {\n      if(!sent) {\n        payload = {\n          result: result,\n          error: err\n        };\n\n        if(future.ret) {\n          //for 0.6.4.1 and older\n          future.ret();\n        } else {\n          //for 0.6.5 and newer\n          future.return();\n        }\n      }\n    }\n  }, 0);\n\n  future.wait();\n  sent = true;\n  \n  if(payload.error) {\n    throw new Meteor.Error(500, payload.error.message);\n  } else {\n    return payload.result;\n  }\n};\n"]}