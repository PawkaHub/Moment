)]}'
{"version":3,"file":"/packages/gadicohen:famous-views.js","sources":["gadicohen:famous-views/lib/famous-views.js","gadicohen:famous-views/lib/meteorFamousView.js","gadicohen:famous-views/lib/sequencer.js","gadicohen:famous-views/lib/famous.js","gadicohen:famous-views/lib/famousEach.js","gadicohen:famous-views/lib/famousIf.js","gadicohen:famous-views/lib/famousContext.js","gadicohen:famous-views/lib/modifiers.js","gadicohen:famous-views/lib/views.js","gadicohen:famous-views/lib/views/_simple.js","gadicohen:famous-views/lib/views/ContainerSurface.js","gadicohen:famous-views/lib/views/EdgeSwapper.js","gadicohen:famous-views/lib/views/Flipper.js","gadicohen:famous-views/lib/views/HeaderFooterLayout.js","gadicohen:famous-views/lib/views/Lightbox.js","gadicohen:famous-views/lib/views/RenderController.js","gadicohen:famous-views/lib/views/Scrollview.js","gadicohen:famous-views/lib/views/Surface.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,0C;AACA,uD;;AAEA,iC;AACA,0D;;AAEA,W;AACA,gE;;AAEA,oB;AACA,sC;AACA,8B;AACA,a;AACA,sB;AACA,a;AACA,Q;AACA,4B;AACA,U;AACA,sB;AACA,yB;AACA,G;AACA,C;AACA,+B;AACA,uB;AACA,qB;AACA,4B;AACA,2B;AACA,G;AACA,E;;AAEA,uB;AACA,qC;AACA,+B;AACA,E;;AAEA,mC;AACA,c;AACA,iB;;AAEA,qE;AACA,0B;AACA,mB;AACA,G;;AAEA,E;AACA,qE;AACA,oE;AACA,oD;AACA,G;AACA,+B;AACA,kC;AACA,wD;AACA,6B;AACA,W;AACA,6C;AACA,wD;AACA,C;;AAEA,4B;AACA,mE;AACA,0E;AACA,yB;;AAEA,2C;AACA,8B;AACA,sC;AACA,oC;;;AAGA,2B;AACA,6B;;AAEA,gE;AACA,mB;AACA,iC;AACA,yB;AACA,yB;AACA,qB;AACA,wE;AACA,sD;AACA,yD;;AAEA,M;AACA,iE;AACA,uD;AACA,yB;AACA,+C;AACA,sE;AACA,gF;AACA,sE;AACA,mC;AACA,uD;AACA,4D;AACA,sC;AACA,wC;AACA,6C;;AAEA,U;AACA,uE;AACA,wD;AACA,+D;AACA,W;AACA,wB;;AAEA,sD;AACA,O;AACA,K;AACA,M;;AAEA,8C;AACA,uB;;AAEA,4B;AACA,uD;AACA,K;AACA,E;;AAEA,sB;;AAEA,yB;AACA,E;AACA,iC;AACA,mB;AACA,+C;AACA,yC;AACA,mB;AACA,kD;AACA,E;;AAEA,6C;AACA,qC;AACA,+E;AACA,kB;AACA,C;AACA,I;AACA,6B;AACA,yC;AACA,6E;AACA,sB;AACA,Y;AACA,2G;AACA,K;AACA,K;;AAEA,wC;AACA,oE;AACA,sD;AACA,oD;AACA,M;AACA,gF;AACA,2E;AACA,2E;AACA,gF;AACA,uD;AACA,C;;AAEA,oD;AACA,wE;AACA,sE;AACA,iB;AACA,6B;;AAEA,0D;AACA,8B;AACA,+C;AACA,2B;AACA,2C;;AAEA,mC;AACA,kC;AACA,iB;;AAEA,+B;AACA,2B;AACA,kC;AACA,wC;AACA,uE;AACA,O;AACA,K;;AAEA,2B;AACA,C;;AAEA,iD;AACA,oC;AACA,mC;AACA,4B;AACA,qB;AACA,uB;AACA,gB;AACA,wB;AACA,iB;AACA,sB;AACA,gB;;AAEA,kC;AACA,+C;;AAEA,6C;AACA,Y;AACA,mD;AACA,6D;AACA,iE;AACA,oE;;AAEA,S;AACA,+B;AACA,K;AACA,iB;AACA,4D;AACA,qB;AACA,uB;AACA,K;;AAEA,wB;AACA,uC;AACA,6B;AACA,e;AACA,U;AACA,mC;AACA,wB;AACA,mB;AACA,kB;AACA,G;;AAEA,I;AACA,4B;AACA,qB;AACA,uB;AACA,gB;AACA,wB;AACA,iB;AACA,kC;AACA,iB;AACA,0D;AACA,yC;AACA,+C;AACA,e;AACA,G;AACA,iC;AACA,8B;AACA,I;AACA,C;;AAEA,gC;AACA,e;AACA,yB;AACA,0B;AACA,0B;AACA,8C;AACA,Q;AACA,2B;AACA,G;AACA,iB;AACA,C;;AAEA,8B;;AAEA,0C;AACA,4C;AACA,iB;AACA,4C;AACA,a;AACA,C;AACA,+C;AACA,oB;AACA,uB;AACA,qD;AACA,a;AACA,C;AACA,6B;AACA,8C;AACA,C;;AAEA,S;;;;;;;;;;;;;;;;;;;AClRA,E;AACA,yE;AACA,qE;AACA,wE;AACA,6C;AACA,E;AACA,+E;AACA,G;;AAEA,2B;AACA,+B;;AAEA,wD;AACA,mD;AACA,oC;;AAEA,6B;AACA,qB;;AAEA,uC;;AAEA,Y;AACA,W;;AAEA,yB;AACA,sD;AACA,e;AACA,0B;AACA,U;AACA,sE;AACA,6D;AACA,yB;AACA,+C;AACA,wE;AACA,6C;AACA,2D;AACA,U;AACA,sE;AACA,gF;AACA,sE;AACA,U;AACA,mC;AACA,uD;AACA,kD;AACA,uC;AACA,wC;AACA,mE;AACA,6C;AACA,O;AACA,kC;AACA,Y;AACA,oD;;AAEA,K;AACA,G;AACA,2E;;AAEA,uB;;AAEA,2E;AACA,6B;;AAEA,sE;;AAEA,0D;AACA,0B;AACA,oD;AACA,yC;AACA,6B;AACA,yC;AACA,yC;AACA,M;AACA,G;AACA,E;;AAEA,gD;AACA,uB;AACA,c;AACA,gB;AACA,8B;AACA,mD;AACA,Y;AACA,E;;AAEA,qD;AACA,6B;AACA,+C;AACA,mB;AACA,E;;AAEA,E;AACA,yE;AACA,kE;AACA,sC;;AAEA,mD;AACA,wB;AACA,C;AACA,E;;AAEA,wD;AACA,+B;AACA,E;;AAEA,kE;AACA,mB;AACA,2E;AACA,yC;AACA,4E;;AAEA,oB;AACA,0B;;AAEA,M;AACA,6C;AACA,6D;AACA,+C;AACA,Q;AACA,4E;AACA,mC;AACA,+E;AACA,yE;AACA,M;;AAEA,wB;AACA,wB;;AAEA,iC;AACA,6D;AACA,a;AACA,K;AACA,G;;AAEA,2E;AACA,qB;AACA,iD;AACA,gD;;AAEA,2B;AACA,oB;AACA,oB;AACA,wB;AACA,sC;;AAEA,qE;AACA,8B;AACA,yB;AACA,8E;AACA,qC;AACA,Y;AACA,+B;AACA,wE;AACA,S;AACA,K;AACA,G;AACA,E;;AAEA,iD;AACA,sE;AACA,E;;AAEA,yC;AACA,+B;AACA,0B;AACA,+E;AACA,qC;AACA,E;;AAEA,sC;AACA,0C;AACA,8C;AACA,2D;AACA,6C;AACA,uE;AACA,4C;AACA,Q;AACA,4E;AACA,6C;AACA,G;AACA,E;;AAEA,2D;AACA,gD;AACA,uC;AACA,E;;AAEA,qE;AACA,6C;AACA,E;;AAEA,0D;AACA,+B;AACA,iC;AACA,E;;AAEA,2B;AACA,+B;AACA,E;;AAEA,8B;AACA,4C;AACA,2C;;AAEA,+C;AACA,sG;AACA,wC;AACA,E;;;;;;;;;;;;;;;;;;;AC9MA,iC;;AAEA,8B;AACA,sB;AACA,sB;;AAEA,e;AACA,yB;AACA,2C;AACA,8C;AACA,G;AACA,E;;AAEA,2C;AACA,6C;AACA,kC;;AAEA,qC;AACA,0B;AACA,sD;AACA,+D;AACA,iE;AACA,qD;AACA,kC;AACA,Q;AACA,kC;;AAEA,yC;AACA,e;AACA,E;;AAEA,E;AACA,4B;AACA,E;AACA,oE;AACA,2D;AACA,gC;AACA,G;;AAEA,4C;AACA,oB;AACA,wE;AACA,uE;AACA,4C;AACA,K;AACA,G;AACA,oC;AACA,E;;AAEA,wE;AACA,mB;AACA,kE;;AAEA,gD;AACA,mC;AACA,+D;;AAEA,mE;AACA,gD;;AAEA,yD;AACA,mC;AACA,yD;AACA,0D;AACA,E;;AAEA,E;AACA,mF;AACA,4E;AACA,2E;AACA,iF;AACA,gF;AACA,yE;AACA,G;AACA,oE;AACA,Y;AACA,uD;AACA,wC;AACA,mC;AACA,E;;;;;;;;;;;;;;;;;;;AC/EA,0D;AACA,uD;AACA,sB;AACA,kE;AACA,4C;AACA,E;;AAEA,uC;AACA,mC;AACA,6C;AACA,2D;AACA,+B;AACA,mC;AACA,4C;AACA,wD;AACA,+C;AACA,Y;AACA,e;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,+B;AACA,mB;AACA,kC;;AAEA,gC;AACA,uF;AACA,qC;AACA,yB;AACA,yC;AACA,mD;AACA,Y;AACA,wC;AACA,K;;AAEA,iB;AACA,mC;AACA,U;AACA,mC;AACA,kD;AACA,oB;AACA,kC;AACA,yB;AACA,uD;AACA,G;AACA,C;;AAEA,wE;AACA,6C;AACA,2D;;AAEA,e;AACA,0B;AACA,M;AACA,4B;AACA,yB;;AAEA,I;AACA,oB;AACA,iC;AACA,I;;AAEA,qC;;AAEA,kD;AACA,0C;;AAEA,e;AACA,iB;;AAEA,uD;AACA,+D;AACA,0D;AACA,wB;AACA,wF;;AAEA,0B;AACA,mB;AACA,sB;AACA,M;;AAEA,+B;AACA,6C;;AAEA,M;AACA,4D;AACA,oB;AACA,4C;AACA,mC;AACA,8B;AACA,kC;AACA,oC;AACA,U;AACA,mD;AACA,K;AACA,M;;AAEA,qD;AACA,uB;AACA,mD;AACA,8C;;AAEA,mB;AACA,oC;AACA,yB;AACA,8B;AACA,yE;AACA,6C;AACA,2E;AACA,8E;AACA,K;AACA,G;AACA,C;;AAEA,yB;AACA,sC;AACA,qB;AACA,uE;AACA,qC;AACA,+C;AACA,E;;AAEA,0C;AACA,qB;AACA,mF;AACA,qC;AACA,+C;AACA,E;;AAEA,6C;AACA,8D;AACA,sC;AACA,oE;AACA,uD;AACA,wE;AACA,oD;AACA,oE;AACA,gD;AACA,wD;AACA,sC;AACA,+C;AACA,O;AACA,O;AACA,G;AACA,E;;AAEA,0B;AACA,4B;AACA,sE;;AAEA,oE;AACA,uF;AACA,wD;;AAEA,c;AACA,0C;AACA,mC;AACA,6C;AACA,6B;AACA,+B;AACA,oD;AACA,G;;AAEA,0B;AACA,yE;AACA,+E;AACA,sD;;AAEA,0C;AACA,oC;;AAEA,yE;AACA,qB;AACA,+C;AACA,4C;AACA,2C;AACA,0B;AACA,uB;AACA,yD;AACA,6B;AACA,G;AACA,gF;;AAEA,yE;;AAEA,uD;AACA,0D;AACA,8D;AACA,oB;AACA,gD;AACA,sC;AACA,8B;AACA,oE;;AAEA,I;AACA,kC;AACA,qD;AACA,qD;AACA,mE;AACA,yC;AACA,iC;AACA,gD;AACA,Y;AACA,yB;AACA,K;AACA,sC;AACA,G;AACA,I;;AAEA,qD;;AAEA,mE;AACA,qC;;AAEA,uD;AACA,sB;AACA,0E;AACA,0E;AACA,mB;;AAEA,wE;AACA,uE;AACA,uE;;AAEA,sE;AACA,mE;AACA,4E;AACA,c;AACA,4B;AACA,uC;AACA,kD;AACA,K;;AAEA,G;;AAEA,0E;AACA,0C;AACA,yD;AACA,iC;AACA,+B;;AAEA,6D;AACA,sB;;AAEA,0D;AACA,iE;;AAEA,e;AACA,8C;AACA,wB;AACA,U;AACA,oC;;AAEA,mC;AACA,mC;;AAEA,oB;;AAEA,wB;;AAEA,G;;AAEA,wC;AACA,kC;AACA,uD;;AAEA,qC;AACA,mD;AACA,8C;;;AAGA,mC;AACA,yC;AACA,uC;AACA,sB;AACA,iF;AACA,uD;AACA,8C;AACA,6B;AACA,uC;AACA,kB;AACA,uE;AACA,yC;AACA,U;AACA,kE;AACA,gD;AACA,G;;AAEA,I;AACA,0C;AACA,4E;AACA,+C;AACA,I;;AAEA,I;AACA,0C;AACA,4E;AACA,2B;AACA,I;;AAEA,mE;AACA,qD;AACA,I;AACA,+D;AACA,iB;AACA,6B;AACA,I;;AAEA,0C;;AAEA,yB;AACA,kC;AACA,2D;AACA,S;AACA,qF;AACA,Q;AACA,gE;;AAEA,+B;;AAEA,+B;AACA,2C;AACA,sF;AACA,e;AACA,U;AACA,oE;AACA,yC;AACA,G;;AAEA,I;AACA,kC;AACA,+C;AACA,4C;AACA,I;;AAEA,I;AACA,0E;AACA,2E;AACA,K;;AAEA,4B;AACA,2B;AACA,yC;AACA,uE;AACA,oD;AACA,6B;AACA,mF;AACA,kC;AACA,sF;AACA,sF;AACA,4B;AACA,Q;AACA,8C;AACA,6B;AACA,K;;AAEA,I;AACA,2E;AACA,wE;AACA,yC;AACA,K;AACA,I;AACA,iB;AACA,uD;AACA,I;AACA,C;;AAEA,E;AACA,+D;AACA,uE;AACA,E;AACA,qE;AACA,kE;AACA,+D;AACA,yC;AACA,E;AACA,qE;AACA,iE;AACA,G;AACA,4B;AACA,gC;AACA,C;;AAEA,gE;;AAEA,gC;AACA,2C;AACA,gD;AACA,yB;AACA,wC;AACA,0C;AACA,gC;;AAEA,qB;AACA,kB;AACA,2B;AACA,4B;AACA,oC;AACA,oD;AACA,sC;AACA,iB;AACA,0E;AACA,iE;AACA,6C;AACA,O;AACA,K;;AAEA,M;AACA,mB;AACA,M;AACA,oE;AACA,mE;AACA,M;AACA,O;;AAEA,iD;;AAEA,4C;AACA,4B;AACA,wB;AACA,qC;AACA,qE;AACA,kC;AACA,8C;AACA,8E;AACA,qE;AACA,6C;AACA,2C;AACA,S;AACA,O;;AAEA,O;;AAEA,wB;AACA,iC;AACA,gB;AACA,G;AACA,E;;AAEA,iD;AACA,yC;AACA,6C;;;;;;;;;;;;;;;;;;;AC3bA,wD;AACA,6B;AACA,4E;AACA,yE;;AAEA,uD;AACA,4C;AACA,gC;AACA,mC;AACA,0B;;AAEA,6D;AACA,mC;AACA,Q;AACA,2C;AACA,yC;AACA,yD;AACA,4C;AACA,a;;AAEA,Y;AACA,mF;AACA,+E;AACA,8C;AACA,a;AACA,+E;AACA,qD;;AAEA,0C;AACA,8C;AACA,0C;;AAEA,6D;AACA,mC;AACA,+D;AACA,kE;;AAEA,0D;AACA,2D;AACA,a;;AAEA,yD;AACA,4E;AACA,W;AACA,Q;AACA,6C;AACA,iC;AACA,kD;AACA,oC;AACA,W;AACA,Q;AACA,yD;AACA,iC;AACA,yD;AACA,W;AACA,Q;AACA,uD;AACA,kC;AACA,sD;AACA,4C;;AAEA,kD;AACA,4C;AACA,W;AACA,O;AACA,O;AACA,C;;AAEA,8B;AACA,4B;AACA,oE;AACA,4B;;AAEA,uD;AACA,+D;AACA,oE;;;AAGA,kD;AACA,2B;AACA,mD;;AAEA,sD;AACA,uC;AACA,8E;AACA,wC;AACA,S;AACA,K;AACA,C;;AAEA,gC;AACA,gC;AACA,C;;AAEA,gE;;AAEA,oC;AACA,+C;AACA,gD;AACA,0D;AACA,yB;AACA,gB;AACA,G;AACA,E;;AAEA,yD;AACA,iD;AACA,qD;;AAEA,E;AACA,wD;AACA,iD;AACA,gB;AACA,K;;AAEA,iC;AACA,yD;AACA,kC;AACA,qC;AACA,4B;;;AAGA,K;;AAEA,kB;AACA,C;AACA,+C;AACA,E;;;;;;;;;;;;;;;;;;;AC/HA,E;AACA,8E;AACA,gF;AACA,+E;AACA,uE;AACA,G;;AAEA,kB;AACA,8D;AACA,kE;AACA,G;;AAEA,4B;AACA,4B;AACA,oE;;AAEA,qD;AACA,+D;AACA,oE;;AAEA,0B;;AAEA,qD;AACA,2B;AACA,mD;AACA,K;AACA,C;;AAEA,qC;AACA,0C;AACA,yC;AACA,wC;AACA,C;;AAEA,8B;AACA,gC;AACA,C;;AAEA,0D;AACA,uB;AACA,2C;;AAEA,2D;AACA,8B;AACA,+D;AACA,oE;;AAEA,gD;AACA,yD;AACA,yD;AACA,O;;AAEA,gD;AACA,gD;;AAEA,2B;AACA,0D;AACA,+B;;AAEA,8B;AACA,mE;;AAEA,iB;AACA,8E;AACA,K;AACA,G;;AAEA,qD;AACA,6C;AACA,iD;;;;;;;;;;;;;;;;;;;ACrEA,yE;AACA,oC;;AAEA,+D;AACA,wD;AACA,iC;AACA,yB;AACA,kC;AACA,0C;AACA,oC;AACA,0C;AACA,oC;AACA,4B;AACA,2B;AACA,yB;AACA,oB;AACA,oB;AACA,O;AACA,G;AACA,0E;AACA,iC;;AAEA,oE;AACA,6E;AACA,2E;;AAEA,6E;AACA,sB;;AAEA,kD;AACA,qD;AACA,qD;AACA,oB;AACA,gD;AACA,sC;AACA,8B;AACA,oE;;AAEA,sB;AACA,wB;AACA,oB;AACA,kD;AACA,mC;AACA,gC;AACA,0B;AACA,oE;AACA,uB;AACA,gC;AACA,Y;AACA,+B;AACA,O;AACA,sB;AACA,wB;AACA,4C;AACA,6C;AACA,K;;AAEA,mE;AACA,8E;AACA,mE;;AAEA,uC;AACA,yC;AACA,kD;AACA,yD;;AAEA,8B;AACA,iC;AACA,G;;AAEA,oB;AACA,gC;AACA,0B;AACA,0B;AACA,K;AACA,I;AACA,4B;AACA,kC;;AAEA,gC;AACA,8F;AACA,6E;AACA,8B;AACA,oC;;AAEA,6C;AACA,kC;AACA,kB;;AAEA,2E;AACA,gD;AACA,yB;AACA,6E;AACA,gD;AACA,K;;AAEA,uF;AACA,kB;AACA,a;;AAEA,2B;AACA,oC;AACA,iE;AACA,yE;AACA,U;AACA,oD;AACA,K;;AAEA,qB;AACA,gB;AACA,M;AACA,gC;AACA,G;;AAEA,8D;AACA,uE;AACA,oC;;;;;;;;;;;;;;;;;;;ACpHA,mD;;AAEA,iC;AACA,iD;AACA,C;;AAEA,2E;AACA,iE;AACA,4D;AACA,iC;AACA,W;;AAEA,wC;AACA,8B;AACA,Y;AACA,2D;AACA,I;;AAEA,+B;AACA,iE;AACA,8B;AACA,kC;AACA,kC;AACA,E;;AAEA,a;AACA,+B;AACA,kC;;AAEA,4C;AACA,+B;AACA,oC;AACA,sC;AACA,mB;AACA,K;AACA,K;;AAEA,2C;AACA,+B;AACA,oC;AACA,qC;AACA,mB;AACA,K;AACA,K;;AAEA,I;AACA,+D;AACA,8D;AACA,8D;AACA,c;AACA,K;AACA,2D;;AAEA,0D;AACA,6C;AACA,oD;AACA,0B;;AAEA,2B;AACA,Y;AACA,qD;AACA,kD;AACA,M;AACA,G;AACA,gC;AACA,6B;AACA,G;AACA,2E;;AAEA,iE;AACA,wE;AACA,uB;AACA,qF;AACA,wB;AACA,8B;AACA,O;AACA,4F;AACA,kC;AACA,iB;;AAEA,mB;AACA,oE;AACA,yF;AACA,gB;;AAEA,qD;;AAEA,yB;AACA,8C;AACA,6D;AACA,gB;;AAEA,oD;AACA,oE;AACA,8B;AACA,iD;AACA,sD;AACA,iC;AACA,kE;AACA,8C;AACA,8C;AACA,sB;AACA,gB;;AAEA,mC;AACA,kD;AACA,kE;AACA,8C;AACA,oD;AACA,sB;AACA,gB;;AAEA,gD;AACA,kD;AACA,kE;AACA,8C;AACA,0D;AACA,sB;AACA,gB;;AAEA,uD;AACA,yE;AACA,wD;AACA,kE;AACA,8C;AACA,sD;AACA,sB;AACA,gB;AACA,O;AACA,K;AACA,K;;;AAGA,G;;AAEA,E;AACA,+D;AACA,6B;AACA,8B;AACA,mC;AACA,kB;AACA,6B;AACA,0B;AACA,K;AACA,E;;AAEA,kE;AACA,kD;AACA,E;AACA,E;;;;;;;;;;;;;;;;;;;ACrJA,yE;;AAEA,6E;AACA,+D;AACA,0D;AACA,iC;AACA,W;;AAEA,I;AACA,sC;AACA,kC;AACA,mB;AACA,I;;AAEA,+B;AACA,iE;AACA,8B;AACA,kC;AACA,kC;;AAEA,wC;AACA,8B;AACA,kB;AACA,yD;AACA,I;AACA,E;;AAEA,iC;AACA,6C;AACA,C;;AAEA,qE;AACA,2D;AACA,E;AACA,iC;AACA,mB;AACA,wB;AACA,yC;AACA,oD;AACA,wB;AACA,0E;AACA,8B;AACA,0E;AACA,8B;;AAEA,mC;AACA,4B;AACA,0C;;AAEA,M;AACA,wE;AACA,6D;AACA,C;AACA,E;;;;;;;;;;;;;;;;;;;ACrDA,+B;AACA,uE;AACA,8C;AACA,G;;;;;;;;;;;;;;;;;;;ACHA,+B;AACA,2E;;AAEA,6C;AACA,8B;AACA,M;;AAEA,iE;AACA,yB;AACA,iD;AACA,2B;AACA,2C;AACA,iC;AACA,4C;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;AChBA,+B;AACA,8D;AACA,6C;AACA,kB;AACA,qB;;AAEA,wB;AACA,yC;AACA,kC;;AAEA,gC;;AAEA,mB;AACA,iD;AACA,0B;AACA,iC;AACA,M;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACnBA,+B;AACA,sD;AACA,6C;AACA,qC;AACA,0D;AACA,gE;;AAEA,yB;AACA,oC;AACA,O;AACA,mC;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACbA,+B;AACA,4E;AACA,6C;AACA,qC;AACA,e;AACA,+F;AACA,sC;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACTA,Y;;AAEA,+B;AACA,wD;AACA,6C;AACA,kB;AACA,qB;;AAEA,wB;AACA,yC;AACA,kC;;AAEA,gC;;AAEA,mB;AACA,iD;AACA,0B;AACA,iC;AACA,M;AACA,I;;AAEA,+D;AACA,6B;AACA,wC;AACA,e;AACA,sB;AACA,gC;AACA,Y;AACA,mD;AACA,S;AACA,I;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACjCA,oC;AACA,2D;;AAEA,6B;AACA,W;AACA,uC;AACA,qB;AACA,I;AACA,wC;AACA,mB;AACA,M;AACA,2E;AACA,G;AACA,e;AACA,0C;AACA,yF;AACA,M;AACA,yC;AACA,6E;AACA,M;AACA,2D;AACA,G;AACA,O;AACA,0C;AACA,iD;AACA,M;AACA,yC;AACA,2D;AACA,M;AACA,2D;AACA,E;AACA,E;;AAEA,0E;AACA,kF;AACA,8C;AACA,4E;AACA,2E;AACA,E;;AAEA,+B;AACA,wE;AACA,6C;AACA,oB;;AAEA,mB;AACA,qB;;AAEA,0B;AACA,6C;AACA,oC;;AAEA,gC;;AAEA,8C;;AAEA,+B;AACA,+C;AACA,+C;AACA,uC;AACA,iC;AACA,I;AACA,uC;AACA,gE;AACA,wE;AACA,e;AACA,0B;AACA,iC;AACA,Y;AACA,sE;AACA,K;AACA,yC;AACA,I;;AAEA,wD;AACA,uE;AACA,4B;AACA,mC;;AAEA,mE;AACA,0C;AACA,+D;AACA,2E;AACA,0B;AACA,iC;AACA,K;AACA,sC;AACA,uD;AACA,M;AACA,I;;AAEA,+D;AACA,6B;AACA,gD;AACA,e;AACA,sC;AACA,0B;AACA,gC;AACA,Y;AACA,8C;AACA,S;AACA,I;AACA,G;AACA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACxGA,+B;AACA,4D;;AAEA,6B;AACA,oB;AACA,yD;;AAEA,yC;;AAEA,2B;AACA,qC;;AAEA,yD;AACA,iD;AACA,uB;AACA,4C;AACA,O;;AAEA,gC;AACA,sC;AACA,+C;AACA,6C;AACA,kC;AACA,oC;AACA,O;AACA,I;;AAEA,qB;AACA,I;;AAEA,iC;AACA,mD;AACA,kD;AACA,oB;AACA,G;;AAEA,I;AACA,G;;;;;;;;;;;;;;;;;;;ACrCA,+B;AACA,qD;;AAEA,6C;AACA,kC;;AAEA,oF;AACA,sD;AACA,8D;AACA,+E;AACA,mC;AACA,kF;;AAEA,iD;AACA,I;;AAEA,iE;AACA,kB;AACA,kB;AACA,2C;AACA,sE;AACA,oE;AACA,kD;AACA,a;AACA,wC;AACA,W;AACA,a;;AAEA,qB;AACA,uB;AACA,wC;AACA,wD;AACA,gD;AACA,iF;AACA,4C;AACA,sC;AACA,gB;;AAEA,qB;AACA,0B;AACA,0C;AACA,+C;AACA,uB;AACA,kD;AACA,yC;AACA,kC;AACA,uD;AACA,a;AACA,gD;AACA,0F;AACA,yC;AACA,gB;AACA,M;AACA,K;;AAEA,I;AACA,G","sourcesContent":["// Could use something from --settings too\nvar isDev = (\"localhost\" === window.location.hostname);\n\nlog = new Logger('famous-views');\nLogger.setLevel('famous-views', isDev ? 'trace' : 'info');\n\nFView = {};\nFView.log = log; // allow other fview-* packages to use this too\n\nvar readyQueue = [];\nvar readyDep = new Tracker.Dependency;\nFView.ready = function(func) {\n  if (func) {\n    if (FView.isReady)\n      func();\n    else\n      readyQueue.push(func);\n  } else {\n    readyDep.depend();\n    return FView.isReady;\n  }\n}\nFView.runReadies = function() {\n  FView.isReady = true;\n  readyDep.changed();\n  while(readyQueue.length) {\n    (readyQueue.shift())();\n  }\n};\n\npostFirstAddQueue = [];\nFView.postFirstAdd = function(func) {\n  postFirstAddQueue.push(func);\n};\n\n// famous-views globals from Famous\nEngine = null;\nTransform = null;\n\nif (typeof(famous) === 'undefined' && typeof(define) !== 'undefined')\ndefine(function(require) {\n//  console.log(1);\n});\n\n/*\n * This must be an exact copy of the function from famous.core.Engine\n * which is not public.  We only use it if famousContext is a direct\n * child of the document body.  Current as of 0.3.1.\n */\ninitializeFamous = function() {\n  // prevent scrolling via browser\n  window.addEventListener('touchmove', function(event) {\n      event.preventDefault();\n  }, true);\n  document.body.classList.add('famous-root');\n  document.documentElement.classList.add('famous-root');\n}\n\nFView.startup = function() {\n  log.debug('Current logging default is \"debug\" (for localhost).  '\n    + 'Change in your app with Logger.setLevel(\"famous-views\", \"info\");');\n  FView.startedUp = true;\n\n  // Globals for inside all of famous-views\n  Engine = famous.core.Engine;\n  Engine.setOptions({appMode: false});\n  Transform = famous.core.Transform;\n\n\n  // Required document.body\n  Meteor.startup(function() {\n\n    // Sanity check, disallow templates with same name as a View\n    var names = [];\n    for (var name in FView.views)\n      if (Template[name])\n        names.push(name);\n    if (names.length)\n      throw new Error(\"You have created Template(s) with the same name \"\n        + \"as these famous-views: \" + names.join(', ')\n        + '.  Nothing will work until you rename them.');\n\n    /*\n    THIS WAS MOVED TO meteorFamousView.js AND IS ONLY CALLED IF A\n    VIEW IS CREATED IN LIMBO AND FVIEW.MAINCTX IS UNSET\n    if (!FView.mainCtx) {\n      if (typeof FView.mainCtx === 'undefined')\n        log.debug('Creating a new main context.  If you already have '\n          + 'your own, set FView.mainCtx = yourMainContext (or to false to get '\n          + 'rid of this warning, or null to not set a mainContext)');\n      if (FView.mainCtx !== null) {\n        var view = FView.famousContext.constructView();\n        var wrapped = Blaze.With({ id:\"mainCtx\", style:\"\" },\n          function() { return view });\n        wrapped.__isTemplateWith = true;\n        Blaze.render(wrapped, document.body);\n\n        /*\n         * Mostly for old way of using iron-router (pre #famousContext)\n         * In future, we could return after Blaze.render\n         * and move stuff below to inside arendered callback */\n         /*\n        Tracker.flush();\n\n        FView.mainCtx = FView.byId(\"mainCtx\").context;\n      }\n    }\n    */\n\n    // Note, various views are registered here\n    FView.runReadies();\n\n    if (Template.famousInit)\n      Blaze.render(Template.famousInit, document.body);\n  });\n};\n\nFView.isReady = false;\n\n// Imports from weak deps\n/*\nif (Package['mjnetworks:famous'])\n  // @famono ignore\n  famous = Package['mjnetworks:famous'].famous;\nelse if (Package['mjnetworks:mj-famous'])\n  // @famono ignore\n  famous = Package['mjnetworks:mj-famous'].famous;\n*/\n\n// Load as ealry as possible, and keep trying\nif (typeof(famous) !== 'undefined') {\n  log.debug(\"Starting up.  famous global found while loading package, great!\");\n  FView.startup();\n}\nelse\n  Meteor.startup(function() {\n    if (typeof(famous) !== 'undefined') {\n      log.debug(\"Starting up.  famous global found during Meteor.startup()\");\n      FView.startup();\n    } else {\n      log.debug(\"No famous global available in Meteor.startup().  Call FView.startup() when appropriate.\");\n    }\n  });\n\nvar optionEval = function(string, key) {\n  if (FView.attrEvalAllowedKeys && (FView.attrEvalAllowedKeys == '*'\n      || FView.attrEvalAllowedKeys.indexOf(key) > -1))\n    return eval(string.substr(5));  // strip \"eval:\"\n  else\n    throw new Error(\"[famous-views] Blocked \" + key + '=\"' + string + '\".  Set '\n      + 'FView.attrEvalAllowedKeys = \"*\" or FView.attrEvalAllowedKeys = [\"'\n      + key + '\"] and make sure you understand the security implications. '\n      + 'Particularly, make sure none of your helper functions return a string '\n      + 'that can be influenced by client-side input');\n}\n\nvar optionBlaze = function(string, key, blazeView) {\n  // temporary, for options that get called (wrongly!) from init as well\n  // or maybe that is the right place and render is the wrong place :)\n  if (!blazeView)\n    return '__FVIEW::SKIP__';\n\n  var args = string.substr(2, string.length-4).split(\" \");\n  var view = blazeView, value;\n  while (view.name.substr(0,9) !== 'Template.')\n    view = view.parentView;\n  value = view.lookup(args.splice(0,1)[0]);\n\n  // Scalar value from data context\n  if (typeof value !== 'function')\n    return value;\n\n  // Reactive value from helper\n  Engine.defer(function() {\n    blazeView.autorun(function() {\n      var run = value.apply(null, args);\n      blazeView.fview._view.attrUpdate.call(blazeView.fview, key, run);\n    });\n  });\n\n  return '__FVIEW::SKIP__';\n}\n\noptionString = function(string, key, blazeView) {\n  if (string.substr(0,5) == 'eval:')\n    return optionEval(string, key);\n  if (string == 'undefined')\n    return undefined;\n  if (string == 'true')\n    return true;\n  if (string == 'false')\n    return false;\n  if (string === null)\n    return null;\n\n  if (string.substr(0,2) === '{{')\n    return optionBlaze(string, key, blazeView);\n\n  if (string[0] == '[' || string[0] == '{') {\n    var obj;\n    string = string.replace(/\\bauto\\b/g, '\"auto\"');\n    string = string.replace(/undefined/g, '\"__undefined__\"');\n    // JSON can't parse values like \".5\" so convert them to \"0.5\"\n    string = string.replace(/([\\[\\{,]+)(\\W*)(\\.[0-9])/g, '$1$20$3');\n\n    try {\n      obj = JSON.parse(string);\n    }\n    catch (err) {\n      log.error(\"Couldn't parse JSON, skipping: \" + string);\n      log.error(err);\n      return undefined;\n    }\n\n    for (var key in obj)\n      if (obj[key] === '__undefined__')\n        obj[key] = undefined;\n    return obj;\n  } else {\n    var float = parseFloat(string);\n    if (!_.isNaN(float))\n      return float;\n    return string;\n  }\n\n  /*\n  if (string == 'undefined')\n    return undefined;\n  if (string == 'true')\n    return true;\n  if (string == 'false')\n    return false;\n  if (string.substr(0,1) == '[') {\n    var out = [];\n    string = string.substr(1, string.length-2).split(',');\n    for (var i=0; i < string.length; i++)\n      out.push(optionString(string[i].trim()));\n    return out;\n  }\n  if (string.match(/^[0-9\\.]+$/))\n    return parseFloat(string);\n  */\n}\n\nhandleOptions = function(data) {\n  options = {};\n  for (var key in data) {\n    var value = data[key];\n    if (_.isString(value))\n      options[key] = optionString(value, key);\n    else\n      options[key] = value;\n  }\n  return options;\n}\n\n/* --- totally not done --- */\n\nFView.showTreeGet = function(renderNode) {\n  var obj = renderNode._node._child._object;\n    if (obj.node)\n      obj.node = this.showTreeGet(obj.node);\n  return obj;\n}\nFView.showTreeChildren = function(renderNode) {\n  var out = {}, i=0;\n  if (renderNode._node)\n    out['child'+(i++)] = this.showTreeGet(renderNode)\n  return out;\n}\nFView.showTree = function() {\n  console.log(this.showTreeChildren(mainCtx));\n}\n\n/* --- */\n","/*\n * Templates are always added to a MeteorFamousView (\"fview\"), in turn is\n * added to it's parent fview or a context.  This allows us to handle\n * situations where a template is later removed (since nodes cannot ever\n * be manually removed from the render tree).\n *\n * http://stackoverflow.com/questions/23087980/how-to-remove-nodes-from-the-ren\n */\n\nvar meteorFamousViews = {};\nvar meteorFamousViewsCount = 0;\n\nMeteorFamousView = function(blazeView, options, noAdd) {\n  this.id = options.id || ++meteorFamousViewsCount;\n  meteorFamousViews[this.id] = this;\n\n  this.blazeView = blazeView;\n  this.children = [];\n\n  // this._callbacks = { destroy: [] };\n\n  if (noAdd)\n    return;\n\n  var parent = blazeView;\n  while ((parent=parent.parentView) && !parent.fview);\n  if (parent) {\n    parent = parent.fview;\n  } else {\n    // backcompat with children created in limbo going to main context\n    // but we should still only create that if we need to now\n    if (!FView.mainCtx) {\n      if (typeof FView.mainCtx === 'undefined')\n        log.debug('Creating a new main context to maintain backwards ' +\n          'compatibility.  Consider using ' +\n          '{{#famousContext id=\"mainCtx\"}} in your body.');\n        /*\n        log.debug('Creating a new main context.  If you already have '\n          + 'your own, set FView.mainCtx = yourMainContext (or to false to get '\n          + 'rid of this warning, or null to not set a mainContext)');\n        */\n      if (FView.mainCtx !== null) {\n        var view = FView.famousContext.constructView();\n        var wrapped = Blaze.With({ id:\"mainCtx\" },\n          function() { return view; });\n        wrapped.__isTemplateWith = true;\n        // Because of id:mainCtx, this populates FView.mainCtxFView\n        Blaze.render(wrapped, document.body);\n      }\n      parent = FView.mainCtxFView;\n    } else {\n      // backcompat, user set FView.mainCtx manually\n\n    }\n  }\n  //parent = parent ? parent.fview : { node: FView.mainCtx, children: [] };\n\n  this.parent = parent;\n\n  // Keep track of fview children, since Meteor only tracks children in DOM\n  parent.children.push(this);\n\n  // Adding to famous parent node, once done here, is now in famous.js\n\n  // Now we have a tree, and a FView.mainCtx if in appMode\n  if (postFirstAddQueue) {\n    for (var i=0; i < postFirstAddQueue.length; i++)\n      Engine.defer(postFirstAddQueue[i]);\n    postFirstAddQueue = null;\n    FView.postFirstAdd = function(func) {\n      Engine.defer(postFirstAddQueue[i]);\n    };\n  }\n};\n\nMeteorFamousView.prototype.render = function() {\n  if (this.isDestroyed)\n    return [];\n  if (this.node)\n    return this.node.render();\n  console.log('render called before anything set');\n  return [];\n};\n\nMeteorFamousView.prototype.setNode = function(node) {\n  // surface or modifier/view\n  this.node = new famous.core.RenderNode(node);\n  return this.node;\n};\n\n/*\n  Replace fview.onDestroy = function() with fview.on('destroy', function)\n  which can be called multiple times.  The old way will still work\n  but will show a deprecation warning.\n\nMeteorFamousView.prototype.onDestroy = function() {\n  return '__original__';\n}\n*/\n\nMeteorFamousView.prototype.preventDestroy = function() {\n  this.destroyPrevented = true;\n};\n\nMeteorFamousView.prototype.destroy = function(isTemplateDestroy) {\n  var fview = this;\n  log.debug('Destroying ' + (fview._view ? fview._view.name : fview.kind) +\n    ' (#' + fview.id + ') and children' +\n    (isTemplateDestroy&&fview.destroyPrevented ? ' (destroyPrevented)':''));\n\n  // XXX ADD TO DOCS\n  if (isTemplateDestroy) {\n\n    /*\n    if (fview.onDestroy() === '__original__')\n      for (var i=0; i < fview._callbacks.destroy.length; i++)\n        fview._calbacks.destroy[i].call(fview);\n    else\n      log.warn('#' + fview.id + ' - you set fview.onDestroy = function().  '\n        + 'This will work for now '\n        + 'but is deprecated.  Please use fview.onDestoy(callback), which may '\n        + 'be used multiple times, and receives the `fview` as `this`.');\n    */\n\n    if (fview.onDestroy)\n      fview.onDestroy();\n\n    if (fview.destroyPrevented) {\n      // log.debug('  #' + fview.id + ' - destroyPrevented');\n      return;\n    }\n  }\n\n  // First delete children (via Blaze to trigger Template destroy callback)\n  if (fview.children)\n    for (var i=0; i < fview.children.length; i++)\n      Blaze.remove(fview.children[i].blazeView);\n\n  fview.isDestroyed = true;\n  fview.node = null;\n  fview.view = null;\n  fview.modifier = null;\n  delete(meteorFamousViews[fview.id]);\n\n  // If we're part of a sequence, now is the time to remove ourselves\n  if (fview.parent.sequence) {\n    if (fview.sequence) {\n      // TODO, we're a child sequence, remove the child (TODO in sequencer.js)\n      // log.debug(\"child sequence\");\n    } else {\n      Engine.defer(function() {\n        fview.parent.sequence.remove(fview);  // less flicker in a defer\n      });\n    }\n  }\n};\n\nMeteorFamousView.prototype.getSize = function() {\n  return this.node && this.node.getSize() || this.size || [true,true];\n};\n\nthrowError = function(startStr, object) {\n  if (object instanceof Object)\n    console.error(object);\n  throw new Error('FView.getData() expects BlazeView or TemplateInstance or ' +\n      'DOM node, but got ' + object);\n};\n\nFView.from = function(viewOrTplorEl) {\n  if (viewOrTplorEl instanceof Blaze.View)\n    return FView.fromBlazeView(viewOrTplorEl);\n  else if (viewOrTplorEl instanceof Blaze.TemplateInstance)\n    return FView.fromTemplate(viewOrTplorEl);\n  else if (viewOrTplorEl && typeof viewOrTplorEl.nodeType === 'number')\n    return FView.fromElement(viewOrTplorEl);\n  else {\n    throwError('FView.getData() expects BlazeView or TemplateInstance or ' +\n        'DOM node, but got ', viewOrTplorEl);\n  }\n};\n\nFView.fromBlazeView = FView.dataFromView = function(view) {\n  while ((view=view.parentView) && !view.fview);\n  return view ? view.fview : undefined;\n};\n\nFView.fromTemplate = FView.dataFromTemplate = function(tplInstance) {\n  return this.dataFromView(tplInstance.view);\n};\n\nFView.fromElement = FView.dataFromElement = function(el) {\n  var view = Blaze.getView(el);\n  return this.dataFromView(view);\n};\n\nFView.byId = function(id) {\n  return meteorFamousViews[id];\n};\n\n// Leave as alias?  Deprecate?\nFView.dataFromCmp = FView.dataFromComponent;\nFView.dataFromTpl = FView.dataFromTemplate;\n\nFView.dataFromComponent = function(component) {\n  log.warn(\"FView.dataFromComponent has been deprecated.  Please use 'FView.fromBlazeView' instead.\");\n  return FView.fromBlazeView(component);\n};\n","/* Sequencer and childSequence */\n\nsequencer = function(parent) {\n  this._sequence = [];\n  this._children = [];\n\n  if (parent) {\n    this.parent = parent;\n    this.childNo = parent._children.length;\n    this.startIndex = parent._sequence.length;\n  }\n};\n\n// TODO, refactor + cleanup for constructor\nsequencer.prototype.child = function(index) {\n  var child = new sequencer(this);\n\n  if (typeof index !== 'undefined') {\n    child.childNo = index;\n    child.startIndex = index < this._children.length ?\n      this._children[index].startIndex : this._sequence.length;\n    // Recall for below loop that child has not been inserted yet\n    for (var i=index; i < this._children.length; i++)\n      this._children[i].childNo++;\n  } else\n    index = this._children.length;\n\n  this._children.splice(index, 0, child);\n  return child;\n};\n\n/*\n * For both functions below:\n *\n *   1. Splice into correct position in parent sequencer's _sequence\n *   2. Update the startIndex of all siblings born after us\n *   3. Modify our own _sequence\n */\n\nsequencer.prototype.push = function(value) {\n  if (this.parent) {\n    this.parent.splice(this.startIndex+this._sequence.length, 0, value);\n    for (var i=this.childNo+1; i < this.parent._children.length; i++) {\n      this.parent._children[i].startIndex++;\n    }\n  }\n  return this._sequence.push(value);\n};\n\nsequencer.prototype.splice = function(index, howMany /*, arguments */) {\n  if (!this.parent)\n    return this._sequence.splice.apply(this._sequence, arguments);\n\n  var diff, max = this._sequence.length - index;\n  if (howMany > max) howMany = max;\n  diff = (arguments.length - 2) - howMany; // inserts - howMany\n\n  for (var i=this.childNo+1; i < this.parent._children.length; i++)\n    this.parent._children[i].startIndex += diff;\n\n  this._sequence.splice.apply(this._sequence, arguments);\n  // add startIndex and re-use args\n  arguments[0] += this.startIndex;  // jshint ignore:line\n  return this.parent.splice.apply(this.parent, arguments);\n};\n\n/*\n * Currently we don't keep track of our children and descedent children separately,\n * so grandChild.push(x) && parent.remove(x) would break everything.  That's\n * because x lands up in our top-level list, and there's nothing to stop us\n * from removing it from the wrong place (and breaking all indexes).  Although as\n * long as we don't mistakenly do this in our code, the only way this can happen\n * is if x exists in both the grandParent and grandChild (not supported).\n */\nsequencer.prototype.remove = function(value /*, suspectedIndex */) {\n  var index;\n  for (index=0; index < this._sequence.length; index++)\n    if (this._sequence[index] === value)\n      return this.splice(index, 1);\n};\n","/* Extend Meteor Template framework for .famousEvents() */\nTemplate.prototype.famousEvents = function (eventMap) {\n  var template = this;\n  template.__famousEventMaps = (template.__famousEventMaps || []);\n  template.__famousEventMaps.push(eventMap);\n};\n\nfunction setupEvents(fview, template) {\n  if (template.__famousEventMaps) {\n    var target = fview.surface || fview.view;\n    _.each(template.__famousEventMaps, function(eventMap) {\n      for (var k in eventMap) {\n        target.on(k, (function(k) {\n          return function(/* arguments */) {\n            Array.prototype.push.call(arguments, fview);\n            eventMap[k].apply(this, arguments);\n          };\n        })(k));\n      }\n    });\n  }\n}\n\nfunction autoHeight(callback) {\n  var fview = this;\n  var div = fview.surface.content;\n\n  var height = div.scrollHeight;\n  if (height && (!fview.size || (fview.size.length == 2 && fview.size[1] != height))) {\n    fview.size = [undefined, height];\n    if (fview.modifier) {\n      fview.modifier.setSize(fview.size);\n      fview.surface.setSize([undefined,undefined]);\n    } else {\n      fview.surface.setSize(fview.size);\n    }\n\n    if (callback)\n      callback.call(fview, height);\n  } else {\n    // Ideally Engine.nextTick, but\n    // https://github.com/Famous/famous/issues/342\n    // e.g. /issue10\n    window.setTimeout(function() {\n      fview.autoHeight();\n    }, 10);  // FYI: 16.67ms = 1x 60fps animation frame\n  }\n}\n\nfunction templateSurface(div, fview, renderedTemplate, tName, options) {\n  // var div = document.createElement('div');\n  var autoSize = options.size && options.size[1] == 'auto';\n\n  if (autoSize)\n    options.size = [0, 0];\n  else\n    div.style.height='100%';\n  div.style.width='100%';\n\n  /*\n  if (fview.uiHooks)\n    div._uihooks = fview.uiHooks;\n  */\n\n//  UI.insert(renderedTemplate, div);\n\n//  we're now forced to always render in main func\n//  renderedTemplate.domrange.attach(div);\n\n  if (!options)\n    options = {};\n\n  // If any HTML was generated, create a surface for it\n  if (options.view=='Surface' || div.innerHTML.trim().length) {\n    fview.surfaceClassName = 't_'+tName.replace(/ /, '_');\n    if (options.classes)\n      throw new Error('Surface classes=\"x,y\" is deprecated.  Use class=\"x y\" instead.');\n\n    var surfaceOptions = {\n      content: div,\n      size: fview.size\n    };\n\n    fview.surface = fview.view;\n    fview.surface.setOptions(surfaceOptions);\n\n    /*\n    fview.surface = new famous.core.Surface(surfaceOptions);\n    if (!fview.node)\n      // nothing, i.e. Surface & no modifier\n      fview.setNode(fview.surface);\n    else if (!fview.sequencer)\n      // add Surface as only child\n      fview.node.add(fview.surface);\n    else {\n      fview.sequencer.sequence.push(fview.surface);\n    }\n    */\n\n    var pipeChildrenTo = fview.parent.pipeChildrenTo;\n    if (pipeChildrenTo)\n      for (var i=0; i < pipeChildrenTo.length; i++)\n        fview.surface.pipe(pipeChildrenTo[i]);\n\n    if (autoSize) {\n      fview.autoHeight = autoHeight;\n      fview.autoHeight();\n      // Deprecated 2014-11-01\n      log.warn(fview.surfaceClassName + ': size=\"[undefined,auto\"] is ' +\n        'deprecated.  Since Famo.us 0.3.0 ' +\n        'you can simply use size=\"[undefined,true]\" and it will work as ' +\n        'expected in all cases (including SequentialLayout, Scrollview, etc');\n    }\n  }\n}\n\n// Used by famousEach too\nparentViewName = function(blazeView) {\n  while (blazeView &&\n      (blazeView.name == \"with\" || blazeView.name == \"(contentBlock)\"))\n    blazeView = blazeView.parentView;\n  return blazeView ? blazeView.name : '(root)';\n};\n\nparentTemplateName = function(blazeView) {\n  while (blazeView &&\n      !blazeView.name.match(/^Template/) && !blazeView.name.match(/^body_content/))\n    blazeView = blazeView.parentView;\n  return blazeView ? blazeView.name : '(none)';\n};\n\n// Need to fire manually at appropriate time,\n// for non-Surfaces which are never added to the DOM by meteor\nrunRenderedCallback = function(view) {\n//  if (view._callbacks.rendered && view._callbacks.rendered.length)\n  var needsRenderedCallback = true; // uh yeah, TODO :>\n  view.domrange = null; // TODO, check if it's a surface / real domrange\n  if (needsRenderedCallback && ! view.isDestroyed &&\n      view._callbacks.rendered && view._callbacks.rendered.length) {\n    Tracker.afterFlush(function callRendered() {\n      if (needsRenderedCallback && ! view.isDestroyed) {\n        needsRenderedCallback = false;\n        Blaze._fireCallbacks(view, 'rendered');\n      }\n    });\n  }\n};\n\nfunction famousCreated() {\n  var blazeView = this.view;\n  var famousViewName = blazeView.name ? blazeView.name.substr(7) : \"\";\n\n  // don't re-use parent's data/attributes, don't mutate data object\n  var inNewDataContext = blazeView.parentView && blazeView.parentView.__isTemplateWith;\n  var data = inNewDataContext ? _.clone(this.data) : {};\n\n  // deprecate\n  if (!data.view && famousViewName === \"\")\n    data.view = 'SequentialLayout';\n  if (!data.view) data.view = famousViewName;\n  else if (!famousViewName) {\n    famousViewName = data.view;\n    blazeView.viewName = 'Famous.' + famousViewName;\n  }\n\n  // Deprecated 2014-08-17\n  if (data.size && _.isString(data.size) && data.size.substr(0,1) != '[')\n    throw new Error('[famous-views] size=\"' + data.size + '\" is deprecated, ' +\n      'please use size=\"['+ data.size + ']\" instead');\n\n  // See attribute parsing notes in README\n  var options = handleOptions(data);\n\n  // These require special handling (but should still be moved elsewhere)\n  if (data.direction)\n    options.direction = data.direction == \"Y\" ?\n      famous.utilities.Utility.Direction.Y :\n      famous.utilities.Utility.Direction.X;\n  if (options.translate) {\n    options.transform =\n      Transform.translate.apply(null, options.translate);\n    delete options.translate;\n  }\n  // any other transforms added here later must act on existing transform matrix\n\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, options);\n\n  var pViewName = parentViewName(blazeView.parentView);\n  var pTplName = parentTemplateName(blazeView.parentView);\n  log.debug('New ' + famousViewName + \" (#\" + fview.id + ')' +\n    (data.template ?\n      ', content from \"' + data.template + '\"' :\n      ', content from inline block') +\n    ' (parent: ' + pViewName +\n    (pViewName == pTplName ? '' : ', template: ' + pTplName) + ')');\n\n  /*\n  if (FView.viewOptions[data.view]\n      && FView.viewOptions[data.view].childUiHooks) {\n    // if childUiHooks specified, store them here too\n    fview.childUiHooks = FView.viewOptions[data.view].childUiHooks;\n  } else if (fview.parent.childUiHooks) {\n    if (data.view == 'Surface') {\n      fview.uiHooks = fview.parent.childUiHooks;\n    } else {\n      // Track descedents\n    }\n    console.log('child ' + data.view);\n  }\n  */\n\n  var view, node, notReallyAView=false /* TODO :) */;\n\n  // currently modifiers come via 'view' arg, for now (and Surface)\n  if (data.view /* != 'Surface' */) {\n\n    var registerable = FView._registerables[data.view];\n    if (!registerable)\n      throw new Error('Wanted view/modifier \"' + data.view + '\" but it ' +\n        'doesn\\'t exists.  Try FView.registerView/Modifier(\"'+ data.view +\n        '\", etc)');\n\n    fview['_' + registerable.type] = registerable;        // fview._view\n    node = registerable.create.call(fview, options);      // fview.node\n    fview[registerable.type] = node;                      // fview.view\n\n    // PEM: TODO when node is a sequence container, its content should\n    // be created before it. Hence, the sequence could be filled so\n    // that instanciation of the container knows exactly what is the content\n    // manage.\n    if (node.sequenceFrom) {\n      fview.sequence = new sequencer();\n      node.sequenceFrom(fview.sequence._sequence);\n    }\n\n  }\n\n  // If no modifier used, default to Modifier if origin/translate/etc used\n  if (!data.modifier && !fview.modifier &&\n      (data.origin || data.translate || data.transform ||\n      (data.size && !node.size)))\n    data.modifier = 'Modifier';\n\n  // Allow us to prepend a modifier in a single template call\n  if (data.modifier) {\n\n    fview._modifier = FView._registerables[data.modifier];\n    fview.modifier = fview._modifier.create.call(fview, options);\n\n    if (node) {\n      fview.setNode(fview.modifier).add(node);\n      fview.view = node;\n    } else\n      fview.setNode(fview.modifier);\n\n    if (fview._modifier.postRender)\n      fview._modifier.postRender();\n\n  } else if (node) {\n\n    fview.setNode(node);\n\n  }\n\n  // could do pipe=1 in template helper?\n  if (fview.parent.pipeChildrenTo)\n    fview.pipeChildrenTo = fview.parent.pipeChildrenTo;\n\n  // think about what else this needs\n  if (fview._view && fview._view.famousCreatedPost)\n    fview._view.famousCreatedPost.call(fview);\n\n\n  // Render contents (and children)\n  var newBlazeView, template, scopedView;\n  if (blazeView.templateContentBlock) {\n    if (data.template)\n      throw new Error(\"A block helper {{#View}} cannot also specify template=X\");\n    // Called like {{#famous}}inlineContents{{/famous}}\n    template = blazeView.templateContentBlock;\n  } else if (data.template) {\n    template = Template[data.template];\n    if (!template)\n      throw new Error('Famous called with template=\"' + data.template +\n        '\" but no such template exists');\n  } else {\n    // Called with inclusion operator but not template {{>famous}}\n    throw new Error(\"No template='' specified\");\n  }\n\n  /*\n  newBlazeView = template.constructView();\n  scopedView = Blaze.With(dataContext, function() { return newBlazeView; });\n  Blaze.materializeView(scopedView, blazeView);\n  */\n\n  /*\n  newBlazeView = Blaze.render(function() {\n    Blaze.With(dataContext, function() { return template.constructView(); })\n  }, div, null, blazeView);\n  */\n\n  // Avoid Blaze running rendered() before it's actually on the DOM\n  // Delete must happen before Blaze.render() called.\n  /*\n  var onRendered = data.view == 'Surface' && template.rendered;\n  if (onRendered)\n    delete template.rendered;\n  */\n\n  var div = document.createElement('div');\n\n  if (inNewDataContext) {\n    var dataContext = data.data ||\n      Blaze._parentData(1) && Blaze._parentData(1, true) ||\n      {};\n    newBlazeView = Blaze.renderWithData(template, dataContext, div, null, blazeView);\n  } else\n    newBlazeView = Blaze.render(template, div, null, blazeView);\n\n  setupEvents(fview, template);\n\n  if (data.view == 'Surface') {\n    templateSurface(div, fview, scopedView,\n      data.template || parentTemplateName(blazeView.parentView).substr(9) + '_inline',\n      options);\n  } else {\n    // no longer necessary since we're forced to render to a div now\n    // runRenderedCallback(newBlazeView);\n  }\n\n  /*\n  var template = options.template;\n  if (template && Template[template].beforeAdd)\n    Template[template].beforeAdd.call(this);\n  */\n\n  /*\n   * This is the final step where the fview is added to Famous Render Tree\n   * By deferring the actual add we can prevent flicker from various causes\n   */\n\n  var parent = fview.parent;\n  Engine.defer(function() {\n    if (parent._view && parent._view.add)\n      // views can explicitly handle how their children should be added\n      parent._view.add.call(parent, fview, options);\n    else if (parent.sequence)\n      // 'sequence' can be an array, sequencer or childSequencer, it doesn't matter\n      parent.sequence.push(fview);\n    else if (!parent.node || (parent.node._object && parent.node._object.isDestroyed))\n      // compView->compView.  long part above is temp hack for template rerender #2010\n      parent.setNode(fview);\n    else\n      // default case, just use the add method\n      parent.node.add(fview);\n  });\n\n  /*\n   * Now that the Template has been rendered to the Famous Render Tree (and\n   * also to the DOM in the case of a Surface), let's run any rendered()\n   * callback that may have been defined.\n   */\n  /*\n  if (onRendered)\n    onRendered.call(fview.blazeView._templateInstance);\n  */\n}\n\n/*\n * This is called by Blaze when the View/Template is destroyed,\n * e.g. {{#if 0}}{{#Scrollview}}{{/if}}.  When this happens we need to:\n *\n * 1) Destroy children (Blaze won't do it since it's not in the DOM),\n *    and any \"eaches\" that may have been added from a famousEach.\n * 2) Call fview.destroy() which handles cleanup w.r.t. famous,\n *    which lives in meteorFamousView.js.\n *\n * It's possible we want to have the \"template\" destroyed but not the\n * fview in the render tree to do a graceful exit animation, etc.\n */\nfunction famousDestroyed() {\n  this.view.fview.destroy(true);\n}\n\n// Keep this at the bottom; Firefox doesn't do function hoisting\n\nFView.famousView = new Template(\n  'famous',           // viewName: \"famous\"\n  function() {        // Blaze.View \"renderFunc\"\n    var blazeView = this;\n    var data = Blaze.getData(blazeView);\n    var tpl = blazeView._templateInstance;\n    var fview = blazeView.fview;\n\n    var changed = {};\n    var orig = {};\n    for (var key in data) {\n      var value = data[key];\n      if (typeof value === \"string\")\n        value = optionString(value, key, blazeView);\n      if (value === '__FVIEW::SKIP__')\n        continue;\n      if (!EJSON.equals(value, tpl.data[key]) || !blazeView.hasRendered) {\n        orig[key] = blazeView.hasRendered ? tpl.data[key] : null;\n        changed[key] = tpl.data[key] = value;\n      }\n    }\n\n    /*\n     * Think about:\n     *\n     * 1) Should the function get the old value or all old data too?\n     * 2) Should the function get all the new data, but translated?\n     *\n     */\n\n    _.each(['modifier', 'view'], function(node) {\n\n      // If the fview has a modifier or view\n      var what = '_' + node;\n      if (fview[what]) {\n        if (fview[what].attrUpdate) {\n          // If that mod/view wants to finely handle reactive updates\n          for (var key in changed)\n            fview[what].attrUpdate.call(fview,\n              key, changed[key], orig[key], tpl.data, !blazeView.hasRendered);\n        } else if (fview[node].setOptions && blazeView.hasRendered) {\n          // Otherwise if it has a setOptions\n          fview[node].setOptions(tpl.data);\n        }\n      }\n\n    });\n\n//    console.log(view);\n    blazeView.hasRendered = true;\n    return null;\n  }\n);\n\nBlaze.registerHelper('famous', FView.famousView);\nFView.famousView.created = famousCreated;\nFView.famousView.destroyed = famousDestroyed;\n","function famousEachRender(eachView, template, argFunc) {\n  var fview = eachView.fview;\n  var sequence = fview.sequence;            // fviews for Famous Render Tree\n  var children = fview.children = [];       // each contentBlock instance\n\n  // For Blaze.currentView (see blaze/builtins.js#each)\n  eachView.argVar = new Blaze.ReactiveVar();\n  eachView.autorun(function () {\n    eachView.argVar.set(argFunc());\n  }, eachView.parentView);\n\n  eachView.stopHandle = ObserveSequence.observe(function () {\n      return eachView.argVar.get();\n    }, {\n      addedAt: function (id, item, index) {\n        Tracker.nonreactive(function () {\n          var newItemView = Blaze.With(item, function() {\n            return template.constructView();\n          });\n\n          /*\n           * This is the repeated block inside famousEach, but not the actual node/\n           * view/surface that gets created on render as this block's children.\n           * We create a pseudo-fview for this\n           */\n          newItemView.fview = new MeteorFamousView(null, {}, true /* noAdd */);\n          newItemView.fview.kind = 'famousEachBlock';\n\n          if (fview.parent.pipeChildrenTo)\n            newItemView.fview.pipeChildrenTo =\n              fview.parent.pipeChildrenTo;\n\n          // Maintain ordering with other deferred operations\n          Engine.defer(function() {\n            newItemView.fview.sequence = sequence.child(index);\n            children.splice(index, 0, { blazeView: newItemView });\n\n            var unusedDiv = document.createElement('div');\n            Blaze.render(newItemView, unusedDiv, eachView);\n          });\n\n          //Blaze.materializeView(newItemView, eachView);\n          //runRenderedCallback(newItemView);  // now called by Blaze.render\n        });\n      },\n      removedAt: function (id, item, index) {\n        Engine.defer(function() {\n          Blaze.remove(children[index].blazeView);\n          children.splice(index, 1);\n        });\n      },\n      changedAt: function (id, newItem, oldItem, index) {\n        Engine.defer(function() {\n          children[index].blazeView.dataVar.set(newItem);\n        });\n      },\n      movedTo: function (id, doc, fromIndex, toIndex) {\n        Engine.defer(function () {\n          var item = sequence.splice(fromIndex, 1)[0];\n          sequence.splice(toIndex, 0, item);\n\n          item = children.splice(fromIndex, 1)[0];\n          children.splice(toIndex, 0, item);\n        });\n      }\n    });\n}\n\nfunction famousEachCreated() {\n  var blazeView = this.view;\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, {});\n  fview.kind = 'famousEach';\n\n  log.debug('New famousEach' + \" (#\" + fview.id + ')' +\n    ' (parent: ' + parentViewName(blazeView.parentView) + ',' +\n    ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n\n  // Maintain order with other deferred operations\n  Engine.defer(function() {\n    fview.sequence = fview.parent.sequence.child();\n\n    // Contents of {{#famousEach}}block{{/famousEach}}\n    if (blazeView.templateContentBlock)\n      famousEachRender(blazeView, blazeView.templateContentBlock, function() {\n        return Blaze.getData(blazeView);\n      });\n  });\n}\n\nfunction famousEachDestroyed() {\n  this.view.fview.destroy(true);\n}\n\n// Keep this at the bottom; Firefox doesn't do function hoisting\n\nFView.famousEachView = new Template(\n  'famousEach',       // viewName: \"famousEach\"\n  function() {        // Blaze.View \"renderFunc\"\n    var view = this;  // Blaze.View, viewName \"famousEach\"\n    // console.log(view);\n    return null;\n  }\n);\n\nBlaze.registerHelper('famousEach', FView.famousEachView);\nFView.famousEachView.created = famousEachCreated;\nFView.famousEachView.destroyed = famousEachDestroyed;\n\n/*\nFView.Each = function (argFunc, contentFunc, elseFunc) {\n  var eachView = Blaze.View('Feach', function() {\n    return null;\n  });\n\n  eachView.onCreated(function() {\n    // For Blaze.currentView (see blaze/builtins.js#each)\n    eachView.autorun(function () {\n      eachView.argVar.set(argFunc());\n    }, eachView.parentView);\n\n\n  });\n\n  return eachView;\n}\nBlaze.registerHelper('famousEach', FView.Each);\n*/\n","/*\n * In brief, on Create we setup a child sequence to serve as a placeholder for\n * any children (so that order is retained).  On reactive render, we destroy any\n * existing children and render the contentBlock / elseBlock (as our children).\n * On destroy, we cleanup and remove (TODO) child sequence placeholder.\n */\n\n/* Other thoughts:\n * - Currently this is only used to retain order in a sequence\n * - If used in a surface we could force rerun of autoHeight, etc?\n */\n\nfunction famousIfCreated() {\n  var blazeView = this.view;\n  var fview = blazeView.fview = new MeteorFamousView(blazeView, {});\n\n  log.debug('New famousIf' + \" (#\" + fview.id + ')' +\n    ' (parent: ' + parentViewName(blazeView.parentView) + ',' +\n    ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n  fview.kind = 'famousIf';\n\n  // Maintain ordering with other deferred operations\n  Engine.defer(function() {\n    fview.sequence = fview.parent.sequence.child();\n  });\n}\n\nfunction cleanupChildren(blazeView) {\n  var children = blazeView.fview.children;\n  for (var i=0; i < children.length; i++)\n    Blaze.remove(children[i].blazeView);\n}\n\nfunction famousIfDestroyed() {\n  this.view.fview.destroy(true);\n}\n\nFView.famousIfView = new Template('famousIf', function() {\n  var blazeView = this;\n  var condition = Blaze.getData(blazeView);\n\n  log.debug('famousIf' + \" (#\" + blazeView.fview.id + ')' +\n    ' is now ' + !!condition +\n    ' (parent: ' + parentViewName(blazeView.parentView) + ',' +\n    ' template: ' + parentTemplateName(blazeView.parentView) + ')');\n\n  var dataContext = null /* this.data.data */ ||\n    Blaze._parentData(1) && Blaze._parentData(1, true) ||\n    Blaze._parentData(0) && Blaze._parentData(0, true) ||\n    {};\n\n  var unusedDiv = document.createElement('div');\n  var template = blazeView.templateContentBlock;\n\n  Engine.defer(function() {\n    // Any time condition changes, remove all old children\n    cleanupChildren(blazeView);\n\n    var template = condition ?\n      blazeView.templateContentBlock : blazeView.templateElseBlock;\n\n    if (template)\n      Blaze.renderWithData(template, dataContext, unusedDiv, null, blazeView);\n  });\n});\n\nBlaze.registerHelper('famousIf', FView.famousIfView);\nFView.famousIfView.created = famousIfCreated;\nFView.famousIfView.destroyed = famousIfDestroyed;\n","// Flag for inserting CSS rules only if at least one context is declared.\nvar isFamousContextDeclared = false;\n\nvar famousContext = new Template('famousContext', function () {\n  // Only inject CSS rules if a famousContext is created\n  if (!isFamousContextDeclared) {\n    var css = new CSSC();\n    css.add('div.fview-context', {\n      webkitTransformStyle: 'preserve-3d',\n      transformStyle: 'preserve-3d',\n      webkitBackfaceVisibility: 'visible',\n      backfaceVisibility: 'visible',\n      pointerEvents: 'none',\n      position: 'relative',\n      overflow: 'hidden',\n      width: '100%',\n      height: '100%'\n    });\n  }\n  // Ensure that no additional CSS rules for famousContext will get added.\n  isFamousContextDeclared = true;\n\n  // don't re-use parent's data/attributes, don't mutate data object\n  var inNewDataContext = this.parentView && this.parentView.__isTemplateWith;\n  var data = inNewDataContext ? _.clone(this.templateInstance().data) : {};\n\n  var fview = this.fview = new MeteorFamousView(this, data, true /*noAdd*/ );\n  fview.children = [];\n\n  var pViewName = parentViewName(this.parentView);\n  var pTplName = parentTemplateName(this.parentView);\n  log.debug('New famousContext (#' + fview.id + ')' +\n    (data.template ?\n      ', content from \"' + data.template + '\"' :\n      ', content from inline block') +\n    ' (parent: ' + pViewName +\n    (pViewName == pTplName ? '' : ', template: ' + pTplName) + ')');\n\n  var divOptions = {};\n  if (!data.useParent) {\n    if (data.size) {\n      data.size = optionString(data.size, 'size');\n      for (var i = 0; i < 2; i++) {\n        var size = data.size[i];\n        if (size === true)\n          throw new Error(\"Can't use `true` size on famousContext\");\n        else if (!size)\n          data.size[i] = '100%';\n        else\n          data.size[i] += 'px';\n      }\n      if (!data.style)\n        data.style = '';\n      data.style = \"width: \" + data.size[0];\n      data.style = \"height: \" + data.size[1];\n    }\n\n    if (typeof data.style === 'undefined' && data.id !== 'mainCtx')\n      log.debug('^__ no style=\"\" specified; you probably want to specify a ' +\n        'size, unless you\\'re doing it via CSS on .fview-context');\n\n    divOptions.class = 'fview-context';\n    if (data.id) divOptions.id = data.id;\n    if (data.style) divOptions.style = data.style;\n    if (data.class) divOptions.class += ' ' + data.class;\n\n    if (data.id === \"mainCtx\")\n      FView.mainCtxFView = fview;\n  }\n\n  var addQueue = [];\n  fview.node = fview.context = {\n    add: function (node) {\n      addQueue.push(node);\n    }\n  };\n  if (data.id === \"mainCtx\")\n    FView.mainCtx = fview.context;\n\n  this.onViewReady(function () {\n    var container = data.useParent ? this._domrange.parentElement : this._domrange.members[0];\n    fview.node = fview.context = famous.core.Engine.createContext(container);\n    if (data.id === \"mainCtx\")\n      FView.mainCtx = fview.context;\n\n    for (var i = 0; i < addQueue.length; i++)\n      fview.node.add(addQueue[i]);\n    addQueue = [];\n\n    if (data.id === \"mainCtx\" || (container.parentNode === document.body &&\n        document.body.childElementCount == 1)) {\n      initializeFamous();\n      $(container).removeClass('fview-context').addClass('famous-container');\n      window.dispatchEvent(new Event('resize'));\n    }\n\n    var template = data.template ? Template[data.template] : this.templateContentBlock;\n    if (!template)\n      return;\n\n    if (inNewDataContext) {\n      var dataContext = data.data ||\n        Blaze._parentData(1) && Blaze._parentData(1, true) || {};\n      Blaze.renderWithData(template, dataContext, container, null, this);\n    } else\n      Blaze.render(template, container, null, this);\n  });\n\n  if (data.useParent)\n    return null;\n  else\n    return HTML.DIV(divOptions);\n});\n\nBlaze.Template.registerHelper('famousContext', famousContext);\nBlaze.Template.registerHelper('FamousContext', famousContext); // alias\nFView.famousContext = famousContext;\n","FView._registerables = {};  // used in views.js too\n\nfunction defaultCreate(options) {\n  return new this._modifier.constructor(options);\n}\n\n/* Available in JS via `FView._registerables.Modifier` and in templates via\n  `{{#famous modifier='Scrollview'}}` or just `{{#Modifier}}`. */\nFView.registerModifier = function(name, modifier, options) {\n  if (FView._registerables[name])\n    return;\n\n  FView._registerables[name] = _.extend(\n    { create: defaultCreate },\n    options,\n    { name: name, constructor: modifier, type: 'modifier' }\n  );\n\n  var fview = FView.famousView;\n  var tpl = new Template('Famous.' + name, fview.renderFunction);\n  tpl.created = fview.created;\n  tpl.destroyed = fview.destroyed;\n  Blaze.registerHelper(name, tpl);\n};\n\nvar Modifier;\nFView.ready(function(require) {\n  Modifier = famous.core.Modifier;\n\n  FView.registerModifier('identity', null, {\n    create: function(options) {\n      return new Modifier(_.extend({\n        transform : Transform.identity\n      }, options));\n    }\n  });\n\n  FView.registerModifier('inFront', null, {\n    create: function(options) {\n      return new Modifier(_.extend({\n        transform : Transform.inFront\n      }, options));\n    }\n  });\n\n  /*\n   * \"Modifier\" (the base class) should not be used for dynamic\n   * updates (as per the docs deprecating setXXX methods).  As\n   * such, we set up everything in `create` vs an `attrUpdate`\n   * function.\n   */\n  FView.registerModifier('Modifier', famous.core.Modifier);\n\n  function modifierMethod(fview, method, value, options) {\n    if (typeof options.halt !== 'undefined' ?\n        options.halt : fview.modifierTransitionHalt)\n    fview.modifier.halt();\n\n    fview.modifier[method](\n      value,\n      options.transition || fview.modifierTransition,\n      options.done || fview.modifierTransitionDone\n    );\n  }\n  function degreesToRadians(x) {\n    return x * Math.PI / 180;\n  }\n  FView.registerModifier('StateModifier', famous.modifiers.StateModifier, {\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n      // Allow for values like { value: 30, transition: {}, halt: true }\n      var options = {};\n      if (typeof value === 'object' && value && typeof value.value !== 'undefined') {\n        options = value;\n        value = options.value;\n      }\n      if (typeof oldValue === 'object' && oldValue && typeof oldValue.value !== 'undefined')\n        oldValue = oldValue.value;\n      var amount;\n\n      switch(key) {\n        case 'transform': case 'opacity': case 'align': case 'size':\n          modifierMethod(this, 'set'+key[0].toUpperCase()+key.substr(1), value, options);\n          break;\n\n        // Below are helpful shortcuts for transforms\n\n        case 'translate':\n          modifierMethod(this, 'setTransform',\n            Transform.translate.apply(null, value), options);\n          break;\n\n        case 'scaleX': case 'scaleY': case 'scaleZ':\n          amount = degreesToRadians((value || 0) - (oldValue || 0));\n          var scale = [0,0,0];\n          if (key == 'scaleX') scale[0] = amount;\n          else if (key == 'scaleY') scale[1] = amount;\n          else scale[2] = amount;\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform.scale.apply(null, scale)\n          ), options);\n          break;\n\n        case 'skewX': case 'skewY':\n          amount = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform[key](degreesToRadians(amount))\n          ), options);\n          break;\n\n        case 'skewZ': // doesn't exist in famous\n          amount = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform.skew(0, 0, degreesToRadians(amount))\n          ), options);\n          break;\n\n        case 'rotateX': case 'rotateY': case 'rotateZ':\n          // value might be undefined from Session with no SessionDefault\n          var rotateBy = (value || 0) - (oldValue || 0);\n          modifierMethod(this, 'setTransform', Transform.multiply(\n            this.modifier.getFinalTransform(),\n            Transform[key](degreesToRadians(rotateBy))\n          ), options);\n          break;\n      }\n    }\n  });\n\n\n});\n\n/*\nFView.modifiers.pageTransition = function(blazeView, options) {\n  this.blazeView = blazeView;\n  this.famous = new Modifier({\n    transform : Transform.identity,\n    opacity   : 1,\n    origin    : [-0.5, -0.5],\n    size      : [100, 100]\n  });\n};\n\nFView.modifiers.pageTransition.prototype.postRender = function() {\n  this.famous.setOrigin([0,0], {duration : 5000});\n};\n*/\n","/* Note, `modifiers.js` is called first, so FView.registerables exists */\n\n/* Available in JS via `FView._registerables.Scrollview` and in templates via\n  `{{#famous view='Scrollview'}}` or just `{{#Scrollview}}`. */\nFView.registerView = function(name, famousView, options) {\n  if (FView._registerables[name])\n    return;\n\n  /*\n  var tpl = _.clone(FView.famousView);\n  tpl.viewName = 'Famous.' + name;\n  console.log(tpl);\n  */\n\n  var fview = FView.famousView;\n  var tpl = new Template('Famous.' + name, fview.renderFunction);\n  tpl.created = fview.created;\n  tpl.destroyed = fview.destroyed;\n  Blaze.registerHelper(name, tpl);\n\n  FView._registerables[name] = _.extend(\n    { create: defaultCreate },\n    options || {},\n    { name: name, constructor: famousView, type: 'view' }\n  );\n};\n\nfunction defaultCreate(options) {\n  return new this._view.constructor(options);\n}\n\n/* Do we still need this?  Most people explicitly register views with\n   registerView() these days, to get the template helper */\n/*\nFView.getView = function(name)  {\n  // @famono silent\n  if (FView.views[name])\n    return FView.views[name].constructor;\n  if (typeof Famous !== 'undefined' && Famous[name])\n    return Famous[name];\n  if (typeof Famous !== 'undefined' && famous.Views && Famous.Views[name])\n    return Famous.Views[name];\n  if (typeof famous !== 'undefined' && famous.views && famous.views[name])\n    return famous.views[name];\n\n  /// XXX temp for proof-of-concept\n  if (FView.modifiers[name])\n    return FView.modifiers[name].modifier;\n\n  else\n    throw new Error('Wanted view \"' + name + '\" but it doesn\\'t exists.'\n      + ' Try FView.registerView(\"'+name+'\", require(...))');\n}\n*/\n","FView.ready(function(require) {\n\tFView.registerView('SequentialLayout', famous.views.SequentialLayout);\n\tFView.registerView('View', famous.core.View);\n});\n","FView.ready(function(require) {\n\tFView.registerView('ContainerSurface', famous.surfaces.ContainerSurface, {\n\n\t\tadd: function(child_fview, child_options) {\n\t\t\tthis.view.add(child_fview);\n    },\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n\t\t\tif (key == 'overflow')\n\t\t\t\tthis.view.setProperties({ overflow: value });\n\t\t\telse if (key == 'class')\n\t\t\t\tthis.view.setClasses(value.split(\" \"));\n\t\t\telse if (key == 'perspective')\n\t\t\t\tthis.view.context.setPerspective(value);\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('EdgeSwapper', famous.views.EdgeSwapper, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tif (!this.view)\n\t\t\t\treturn;  // when?\n\n\t\t\tif (this.currentShow)\n\t\t\t\tthis.previousShow = this.currentShow;\n\t\t\tthis.currentShow = child_fview;\n\n\t\t\tchild_fview.preventDestroy();\n\n\t\t\tvar self = this;\n\t\t\tthis.view.show(child_fview, null, function() {\n\t\t\t\tif (self.previousShow)\n\t\t\t\t\tself.previousShow.destroy();\n\t\t\t});\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('Flipper', famous.views.Flipper, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tvar target = child_options.target;\n\t\t\tif (!target || (target != 'back' && target != 'front'))\n\t\t\t\tthrow new Error('Flipper must specify target=\"back/front\"');\n\n\t\t\tif (target == 'front')\n\t\t\t\tthis.view.setFront(child_fview);\n\t\t\telse\n\t\t\t\tthis.view.setBack(child_fview);\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('HeaderFooterLayout', famous.views.HeaderFooterLayout, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tvar target = child_options.target;\n\t\t\tif (!target)\n\t\t\t\tthrow new Error('HeaderFooterLayout children must specify target=\"header/footer/content\"');\n\t\t\tthis.view[target].add(child_fview);\n\t\t}\n\t});\n});\n","// NOT DONE!\n\nFView.ready(function(require) {\n\tFView.registerView('Lightbox', famous.views.Lightbox, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tif (!this.view)\n\t\t\t\treturn;  // when?\n\n\t\t\tif (this.currentShow)\n\t\t\t\tthis.previousShow = this.currentShow;\n\t\t\tthis.currentShow = child_fview;\n\n\t\t\tchild_fview.preventDestroy();\n\n\t\t\tvar self = this;\n\t\t\tthis.view.show(child_fview, null, function() {\n\t\t\t\tif (self.previousShow)\n\t\t\t\t\tself.previousShow.destroy();\n\t\t\t});\n\t\t},\n\n\t\tattrUpdate: function(key, value, oldValue, data, firstTime) {\n\t\t\tif (key == 'transition') {\n\t\t\t\tvar data = FView.transitions[value];\n\t\t\t\tif (data) {\n\t\t\t\t\tfor (key in data)\n\t\t\t\t\t\tthis.view[key](data[key]);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error('No such transition ' + transition);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t});\n});\n","function fullOpacity() { return 1; }\nfunction transformIdentity() { return Transform.Identity; }\n\nFView.transitionModifiers = {\n\topacity: {\n\t\toutOpacityFrom: function (progress) {\n    \treturn progress;\n\t\t},\n    inOpacityFrom: function (progress) {\n\t\t\treturn progress;\n    },\n    outTransformFrom: transformIdentity, inTransformFrom: transformIdentity\n\t},\n\tslideWindow: {\n    outTransformFrom: function(progress) {\n      return Transform.translate(window.innerWidth * progress - window.innerWidth, 0, 0);\n    },\n    inTransformFrom: function(progress) {\n      return Transform.translate(window.innerWidth * (1.0 - progress), 0, 0);\n    },\n    inOpacityFrom: fullOpacity, outOpacityFrom: fullOpacity\n\t},\n\tWIP: {\n    outTransformFrom: function(progress) {\n      return Transform.rotateY(Math.PI*progress);\n    },\n    inTransformFrom: function(progress) {\n      return Transform.rotateY(Math.PI + Math.PI*progress);\n    },\n    inOpacityFrom: fullOpacity, outOpacityFrom: fullOpacity\n\t}\n};\n\n// Other option is to allow a slideDirection attribute.  Think about this.\nFView.transitionModifiers.slideWindowLeft = FView.transitionModifiers.slideWindow;\nFView.transitionModifiers.slideWindowRight = {\n    outTransformFrom: FView.transitionModifiers.slideWindow.inTransformFrom,\n    inTransformFrom: FView.transitionModifiers.slideWindow.outTransformFrom\n};\n\nFView.ready(function(require) {\n\tFView.registerView('RenderController', famous.views.RenderController, {\n\t\tadd: function(child_fview, child_options) {\n\t\t\tvar fview = this;\n\n\t\t\tif (!fview.view)\n\t\t\t\treturn;  // when?\n\n\t\t\tif (fview._currentShow)\n\t\t\t\tfview._previousShow = fview._currentShow;\n\t\t\tfview._currentShow = child_fview;\n\n\t\t\tchild_fview.preventDestroy();\n\n\t\t\tvar transition = fview._transition || null;\n\n\t\t\tvar origTransitionData = {};\n\t\t\tif (fview._transitionOnce !== 'undefined') {\n\t\t\t\torigTransitionData.transition = transition;\n\t\t\t\ttransition = fview._transitionOnce;\n\t\t\t\tdelete fview._transitionOnce;\n\t\t\t}\n\t\t\tif (fview._transitionModifierOnce) {\n\t\t\t\torigTransitionData.modifierName = fview._transitionModifier;\n\t\t\t\tvar data = FView.transitionModifiers[fview._transitionModifierOnce];\n\t\t\t\tif (data) {\n\t\t\t\t\tfor (var key in data)\n\t\t\t\t\t\tfview.view[key](data[key]);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error('No such transition ' + fview._transitionModifierOnce);\n\t\t\t\t}\n\t\t\t\tdelete fview._transitionModifierOnce;\n\t\t\t}\n\n\t\t\tfview.view.show(child_fview, transition, function() {\n\t\t\t\t// Now that transition is complete, we can destroy the old template\n\t\t\t\tif (fview._previousShow)\n\t\t\t\t\tfview._previousShow.destroy();\n\n\t\t\t\t// If _transitionOnce was used, now we can restore the defaults\n\t\t\t\tif (origTransitionData.modifierName) {\n\t\t\t\t\tconsole.log('restore ' + origTransitionData.modifierName);\n\t\t\t\t\tvar data = FView.transitionModifiers[origTransitionData.modifierName];\n\t\t\t\t\tfor (var key in data)\n\t\t\t\t\t\tfview.view[key](data[key]);\n\t\t\t\t}\n\t\t\t\tif (origTransitionData.transition)\n\t\t\t\t\tfview._transition = origTransitionData.transition;\n\t\t\t});\n\t\t},\n\n\t\tattrUpdate: function(key, value, oldValue, data, firstTime) {\n\t\t\tif (key == 'transition') {\n\t\t\t\tvar data = FView.transitionModifiers[value];\n\t\t\t\tif (data) {\n\t\t\t\t\tthis._transitionModifier = value;\n\t\t\t\t\tfor (var key in data)\n\t\t\t\t\t\tthis.view[key](data[key]);\n\t\t\t\t} else {\n\t\t\t\t\tlog.error('No such transition ' + value);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('Scrollview', famous.views.Scrollview, {\n\n\t\tcreate: function(options) {\n\t\t\tvar fview = this;\n\t\t\tvar scrollview = new fview._view.constructor(options);\n\n\t\t\tfview.properties = new ReactiveDict();\n\n\t\t\tif (options.paginated) {\n\t\t\t\tfview.properties.set('index', 0);\n\n\t\t\t\t// famo.us pageChange event seems completely broken??\n\t\t\t\tscrollview.on('pageChange', function(props) {\n\t\t\t\t\tfor (key in props)\n\t\t\t\t\t\tfview.properties.set(key, props[key]);\n\t\t\t\t});\n\n\t\t\t\t// workaround for the above:\n\t\t\t\t// - fires when event doesn't fire\n\t\t\t\t// - will override wrong value before flush\n\t\t\t\tscrollview.on('settle', function(props) {\n\t\t\t\t\tfview.properties.set('index',\n\t\t\t\t\t\tfview.view.getCurrentIndex());\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn scrollview;\n\t\t},\n\n\t\tfamousCreatedPost: function() {\n\t\t\tthis.pipeChildrenTo = this.parent.pipeChildrenTo\n\t\t\t\t? [ this.view, this.parent.pipeChildrenTo[0] ]\n\t\t\t\t: [ this.view ];\n\t\t}\n\n\t});\n});\n","FView.ready(function(require) {\n\tFView.registerView('Surface', famous.core.Surface, {\n\n\t\tadd: function(child_fview, child_options) {\n\t\t\tvar blazeView = this.blazeView;\n\n\t\t  log.error(\"You tried to embed a \" + child_fview._view.name + \" inside a Surface\"\n\t\t    + ' (parent: ' + parentViewName(blazeView) + ','\n\t\t    + ' template: ' + parentTemplateName(blazeView) + ').  '\n\t\t    + \"Surfaces are endpoints in the Famous Render Tree and may not contain \"\n\t\t  \t+ \"children themselves.  See \"\n\t\t    + \"https://github.com/gadicc/meteor-famous-views/issues/78 for more info.\");\n\n\t\t\tthrow new Error(\"Cannot add View to Surface\");\n\t\t},\n\n    attrUpdate: function(key, value, oldValue, data, firstTime) {\n    \tswitch(key) {\n    \t\tcase 'size':\n    \t\t\t// Let our modifier control our size\n    \t\t\t// Long term, rather specify modifierSize and surfaceSize args?\n    \t\t\tif (this._modifier && this._modifier.name == 'StateModifier')\n\t\t\t\t\t\tthis.surface.setSize([undefined,undefined]);\n    \t\t\telse {\n            this.surface.setSize(value);\n          }\n    \t\t\tbreak;\n\n        case 'class':\n        case 'classes':\n          if (Match.test(value, String))\n            value = value == \"\" ? [] : value.split(\" \");\n          else if (!Match.test(value, [String]))\n            throw new Error('Surface class= expects string or array of strings');\n          value.push(this.surfaceClassName);\n          this.view.setClasses(value);\n          break;\n\n        case 'style':\n        case 'properties':\n          if (Match.test(value, String)) {\n            var parts = value.split(';'), pair;\n            value = {};\n            for (var i=0; i < parts.length; i++) {\n              pair = parts[i].split(':');\n              if (pair.length > 1)\n                value[pair[0].trim()] = pair[1].trim();\n            }\n          } else if (!Match.test(value, Object))\n            throw new Error('Surface properties= expects string or key-value dictionary');\n          this.view.setProperties(value);\n          break;\n    \t}\n    }\n\n\t});\n});\n"]}